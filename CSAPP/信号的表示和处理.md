# 信号的表示和处理

- [信号的表示和处理](#信号的表示和处理)
  - [编码](#编码)
    - [无符号(Unsigned)数的编码](#无符号unsigned数的编码)
    - [补码(Two's-complement)数的编码](#补码twos-complement数的编码)
    - [其他编码方式](#其他编码方式)
      - [反码(Ones'Complement)编码](#反码onescomplement编码)
      - [原码(Sign-Magnitude)编码](#原码sign-magnitude编码)
    - [无符号数与补码数的转换](#无符号数与补码数的转换)
      - [补码转无符号](#补码转无符号)
      - [无符号转补码](#无符号转补码)
    - [拓展一个数字的位表示](#拓展一个数字的位表示)
      - [无符号的拓展](#无符号的拓展)
      - [补码数的拓展](#补码数的拓展)
    - [截断数字](#截断数字)
      - [截断无符号数](#截断无符号数)
      - [截断补码数](#截断补码数)
  - [整数运算](#整数运算)
    - [无符号加法](#无符号加法)
      - [无符号加法溢出的检测](#无符号加法溢出的检测)
      - [无符号的非](#无符号的非)
    - [补码加法](#补码加法)
      - [补码加法溢出的判断](#补码加法溢出的判断)
      - [补码的非](#补码的非)
    - [无符号乘法](#无符号乘法)
    - [补码乘法](#补码乘法)
    - [乘以常数](#乘以常数)


## 编码

### 无符号(Unsigned)数的编码

设一个整数数据有 $\omega$ 位，我们可以将其写成位向量 $\vec x$ 来表示该向量，或者将其每一位都写出来

$$
\vec x = [x_{\omega -1},x_{\omega -2},\cdots, x_1,x_0]
$$

对于向量 $\vec x = [x_{\omega -1},x_{\omega -2},\cdots, x_1,x_0]$ ，有：

$$
B2U_{\omega}(\vec x)=\sum_{i=0}^{\omega - 1}x_i 2^{i}
$$

### 补码(Two's-complement)数的编码

对于向量 $\vec x = [x_{\omega -1},x_{\omega -2},\cdots, x_1,x_0]$ ，有：

$$
B2T_{\omega}(\vec x)=-x_{\omega - 1}2^{\omega -1}+\sum_{i=0}^{\omega - 2}x_{i}2^{i}
$$

对于补码数的编码，其实就是**无符号数的最高位变为负数**，其余都是一样的

我们以 $4$ 位的无符号数与补码数为例，讨论二者的表示范围：

对于 $4$ 位的无符号数的范围，有：$0\sim 15$

对于 $4$ 位的补码数的范围，有：$-8\sim 7$

对于补码数而言，负数的个数有 $8$ 个，**非负数**的个数也有 $8$ 个，这导致了：$|TMin_{\omega}|=|TMax_{\omega}+1|$

### 其他编码方式

#### 反码(Ones'Complement)编码

$$
B2O_{\omega}(\vec x)=-x_{\omega - 1}(2^{\omega -1}-1)+\sum_{i=0}^{\omega - 2}x_{i}2^{i}
$$

反码编码只是在**补码的基础上**将最高位的权重从 $-2^{\omega -1}$ 变为 $-(2^{\omega}-1)$，其余都跟补码一样

#### 原码(Sign-Magnitude)编码

$$
B2S_{\omega}(\vec x)=(-1)^{x_{\omega -1}}+\sum_{i=0}^{\omega - 2}x_{i}2^{i}
$$

原码的最高位为**符号位**，其余位来决定该数的大小

这两种编码都有一个问题是，对于数字 $0$ 会有两种解释方式

在原码中 $[00\cdots 0]$ 被解释为 $+0$，$[10\cdots 0]$ 被解释为 $-0$

在反码中 $[00\cdots 0]$ 被解释为 $+0$，$[11\cdots 1]$ 被解释为 $-0$

实际上，浮点数的编码方式就是才有原码编码

### 无符号数与补码数的转换

对于补码和无符号数之间的转换，**底层的位值表示是不变的**，只是改变了**解释这些位的方式**

#### 补码转无符号

$$
T2U_{\omega}(\vec x) = \left \{ \begin{matrix}
x+2^{\omega}, & x \lt 0 \\
x,            & x \ge 0
\end{matrix}\right.
$$

#### 无符号转补码

$$
U2T_{\omega}(\vec x) = \left \{ \begin{matrix}
x , & x\le TMax \\
x-2^{\omega} ,& x \gt TMax
\end{matrix}\right.
$$

### 拓展一个数字的位表示

我们主要讨论从一个较小的类型转换到较大的类型

#### 无符号的拓展

无符号的拓展被称为零拓展(zero extention)，只需要简单的在开头添加 $0$ 即可，其原理如下：

定义长度为 $\omega$ 的位向量 $\vec u=[u_{\omega -1},u_{\omega -2},\cdots ,u_1,u_0]$ 和长度为 $\omega '$ 的位向量 $\vec {u'}=[0,0,\cdots ,0,u_{\omega -1},u_{\omega -2},\cdots ,u_1,u_0]$ ，其中 $\omega '\gt \omega$

此时有：$B2U(\vec{u})=B2U(\vec{u'})$

#### 补码数的拓展

补码数的拓展被称为符号拓展(sign extention)，即在前面**添加最高有效位**

最高有效位为 $0$ ，那么添加 $0$ ；最高有效位为 $1$ ，那么添加 $1$

定义长度为 $\omega$ 的位向量 $\vec u=[u_{\omega -1},u_{\omega -2},\cdots ,u_1,u_0]$ 和长度为 $\omega '$ 的位向量 $\vec {u'}=[{\color{orange}u_{\omega -1},u_{\omega -1},\cdots ,u_{\omega -1}},u_{\omega -1},u_{\omega -2},\cdots ,u_1,u_0]$ ，其中 $\omega '\gt \omega$

我们有：$B2T(\vec{u})=B2T(\vec{u'})$

推导：

我们只需证明：$B2T([{\color {orange}u_{\omega -1}},u_{\omega -2},\cdots ,u_1,u_0])=B2T([{\color {orange}u_{\omega -1},u_{\omega -1}},u_{\omega -2},\cdots ,u_1,u_0])$ ，便可以说明对于**任意位数的符号拓展，都是满足条件的**

我们按照补码数的定义展开，有：

$$
\begin{align*}
B2T([{\color {orange}u_{\omega -1},u_{\omega -1}},u_{\omega -2},\cdots ,u_1,u_0])&=-{\color {orange}u_{\omega -1}}2^{\omega}+\sum_{i=0}^{\omega -1}u_{i}2^{i}\\
&=-{\color {orange}u_{\omega -1}}2^{\omega}+{\color {orange}u_{\omega -1}}2^{\omega-1}+\sum_{i=0}^{\omega-2}u_i2^i\\
&=-{\color {orange}u_{\omega -1}}2^{\omega-1}+\sum_{i=0}^{\omega-2}u_i2^i\\
&=B2T([{\color {orange}u_{\omega -1}},u_{\omega -2},\cdots ,u_1,u_0])
\end{align*}
$$

本质上是使用属性：$2^{\omega}-2^{\omega-1}=2^{\omega-1}$

### 截断数字

#### 截断无符号数

设 $\vec{x}$ 表示位向量 $[x_{\omega-1}, x_{\omega-2}, \cdots x_1,x_0]$，$\vec{x'}$为其**截断为 $k$ 位**的结果：$\vec{x'}=[x_{k-1},x_{k-2},\cdots,x_1,x_0]$，我们有：$x'=x\bmod 2^k$

$$
\begin{align*}
B2U_{\omega}([x_{\omega-1}, x_{\omega-2}, \cdots x_1,x_0])\bmod 2^k&=(\sum_{i=0}^{\omega-1}x_i2^{i})\bmod 2^k\\
&=(\sum_{i=0}^{k-1}x_i2^i)\bmod 2^k\\
&=B2U_{\omega}([x_{k-1},x_{k-2},\cdots,x_1,x_0])
\end{align*}
$$

本质上是对于任意的 $i\ge k$，都有：$2^i\bmod 2^k=0$

#### 截断补码数

设 $\vec{x}$ 表示位向量 $[x_{\omega-1}, x_{\omega-2}, \cdots x_1,x_0]$，$\vec{x'}$为其**截断为 $k$ 位**的结果：$\vec{x'}=[x_{k-1},x_{k-2},\cdots,x_1,x_0]$，我们有：$x'=U2T(x\bmod 2^k)$

本质上是先将位向量**截断为 $k$ 位**，然后在**从补码的角度诠释位表示**

## 整数运算

### 无符号加法

设 $0\le x,y\le 2^{\omega}$，有：

$$
\begin{align*}
x+_{\omega}^{u}y=\left \{ \begin{matrix} &x+y,\quad &x+y\le 2^{\omega}\qquad \text{正常}\\
&x+y-2^{\omega},\quad &x+y\ge 2^{\omega}\qquad \text{溢出}
\end{matrix}\right.
\end{align*}
$$

两个 $\omega$ 位的无符号数相加，其结果可能需要 $\omega+1$ 位来表示

若两个 $\omega$ 位的无符号数相加，如果加和**会自动截断为 $\omega$ 位**

#### 无符号加法溢出的检测

设 $0\le x,y\le UMax_{\omega}$ ，令 $s=x+_{\omega}^{u}y$ ，当且仅当 $s\lt x$ （或等价条件 $s\lt y$）成立时，发生了溢出

代码判断：

```cpp
//未发生溢出时返回true，发生溢出时返回false
bool uadd_ok(unsigned x, unsigned y)
{
    unsigned sum = x + y;
    return sum >= x;
}
```

#### 无符号的非

设 $0\le x\lt 2^{\omega}$ ，其 $\omega$ 位的逆元 $-_{\omega}^{u}x$ 有下式给出：

$$
\begin{align*}
-_{\omega}^{u}x&=\left \{ \begin{matrix} &x,&x=0\\
&2^{\omega}-x,&x\gt 0
\end{matrix} \right.
\end{align*}
$$

求无符号的非，本质上是对于一个无符号数 $x$ ，找到一个 $y$ 使得：

$$
(x+_{\omega}^{u}y)\bmod 2^{\omega}=0
$$

因此直接在 $x$ 的基础上加一个**使其溢出的数**即可

### 补码加法

设 $-2^{\omega-1}\le x,y\le 2^{\omega-1}-1$ ，有：

$$
\begin{align*}
x+_{\omega}^{t}y=\left \{ \begin{matrix}&x+y-2^{\omega},&x+y\ge 2^{\omega-1}\quad &\text{正溢出}\\
&x+y,&-2^{\omega}\le x+y\le 2^{\omega-1}-1 \quad &\text{正常}\\
&x+y+2^{\omega},&x+y\lt -2^{\omega-1} \quad &\text{负溢出}
\end{matrix}\right.
\end{align*}
$$

对于 $\omega$ 位的补码数可表示的最小值为 $-2^{\omega-1}$ ，可表示的最大值为 $2^{\omega-1}-1$

因此如果两个 $\omega$ 位的补码数相加，其结果可能需要 $\omega+1$ 位来表示

如果结果大于 $2^{\omega-1}-1$ ，则发生**正溢出**，$\omega-1$ 位的值由 $0$ 变为 $1$，数值上相当于加和结果**减去** $2\times2^{\omega-1}=2^{\omega}$ 

如果结果小于 $-2^{\omega}$ ，则发生**负溢出**，$\omega$ 位的会溢出为 $1$ ，由于我们需要将该位舍去，因此数值上相当于加和结果**加上** $2^{\omega}$

#### 补码加法溢出的判断

设 $TMin\le x,y\le TMax$ ，令 $s=x+_{\omega}^{t}y$ 

**当且仅当 $x\gt 0,y\gt 0$ 而 $s\le 0$ 时**，发生**正溢出**

**当且仅当 $x\lt 0,y\lt 0$ 而 $s\ge 0$ 时**，发生**负溢出**

代码判断：

```cpp
//返回-1表示负溢出，1表示正溢出，0表示正常
int tadd_ok(int x, int y)
{
    int sum = 0;
    if(x < 0 && y < 0 && sum >= 0) return -1;
    else if(x > 0 && y > 0 && sum <= 0) return 1;
    else return 0;
}
```

该程序不能写成：

```cpp
int tadd_ok(int x, int y)
{
    int sum = x + y;
    return (sum - x == y) && (sum - y == x);
}
```

这是因为，**无论补码加法是否溢出，`sum -x == y` 都始终成立**（补码加法是模数加法，具有循环的特性）

如果需要判断 $x-y$ 是否发生溢出，不能写成：

```cpp
int tsub_ok(int x, int y)
{
    return tadd_ok(x, -y);
}
```

当 $y$ 取除 $TMin$ 以外的任何值时，都是满足条件的，但当 $y=TMin$ 时，此函数做出了与我们期望相反的行为

当 $y=TMin$ 时，该函数认为只要 $x\ge 0$ 时就不会发生溢出，只要 $x\lt 0$时就会发生溢出，但实际与此刚好相反

当 $y=TMin$ 时，$-y=TMin$ ，若 $x\ge 0$ ，其实际计算结果为**正数**，但位表示却为负数，因此发生了溢出；同理，若 $x;t 0$ ，其实际计算结果**依旧**为**正数**，在位表示上，溢出的一位会被舍去，而符号位为 $0$ ，即位表示为正数，因此没有发生溢出

正确写法：

```cpp
//溢出返回1，未溢出返回0
int tsub_ok(int x, int y)
{
    int sub = x - y;
    return (x > 0 && y < 0 && sub < 0) || (x < 0 && y > 0 && sub > 0);
}
```

#### 补码的非

设 $TMin\le x\le TMax$ ，$x$ 的补码非 $-_{\omega}^{t}x$ 由下式给出：

$$
\begin{align*}
-_{\omega}^{t}x=\left \{ \begin{matrix} &TMin,&x=TMin\\
&-x,&x\gt TMin
\end{matrix}\right.
\end{align*}
$$

补码的非本质上同无符号的非一样，都是找一个数 $y$ 使得 $(y+_{\omega}^{t}x)\bmod 2^{\omega}=0$ ，本质上都是模数加法的溢出

### 无符号乘法

对于 $0\le x,y\le UMax$ ，无符号乘法结果由下式给出：

$$
x*_{\omega}^{u}y=(x*y)\bmod 2^{\omega}
$$

两个 $\omega$ 位的数相乘，结果可能需要 $2\omega$ 位才能表示，因此无符号程序会将结果**截断为 $\omega$ 位**

### 补码乘法

对于 $TMin\le x,y\le TMax$ ，补码乘法结果由下式给出：

$$
x*_{\omega}^{t}y=U2T((x*y)\bmod 2^{\omega})
$$

其实就是将乘法结果**截断为 $\omega$ 位，然后再从补码的角度解释**

### 乘以常数

我们先讨论乘以 $2$ 的次幂的情况

无论是无符号数还是补码数，乘以 $2^k$ 相当于将位表示左移 $k$ 个单位，然后再对其进行截断，即：

$$
x*_{\omega}^{u}2^k=B2U((x*2^k)\bmod 2^{\omega})\\
x*_{\omega}^{t}2^k=U2T((x*2^k)\bmod 2^{\omega})
$$

对于乘以任意常数 $K$ 的情况，我们将 $K$ 的二进制表示写出来：$[(0\cdots 0)(1\cdots 1)(0\cdots 0)]$ ，必然会是**连续**的 $0,1$ 交替的情况

例如，$14$ 可以写为 $[(0\cdots0)(111)(0)]$，考虑**位位值**从 $n$ 到 $m$ 的一组连续的 $1$ （$n\ge m$ ，且二者均从 $0$ 开始）。（对 $14$ 来说，$n=3,m=1$）我们可以用以下两种方式来将乘以任意常数 $K$ 转换成加法、减法与移位操作：

* $(x<<n)+(x<<(n-1))+\cdots+(x<<m)$

* $(x<<(n + 1))-(x<<m)$

问题：如果加法、减法、移位所需的时间相同，那么当 $n,m$ 取不同值时，编译器该如何决定选择哪一种操作？

分类讨论：

如果 $n=m$ ，那么第一种只需要一次移位，第二种需要一次减法和两次移位

如果 $n=m+1$ ，那么第一种需要两次移位和一次加法，第二种需要两次移位和一次减法

如果 $n\gt m+1$ ，那么第二种只会需要两次移位和一次减法，第一种需要 $n-m+1$ 次移位和 $n-m$ 次加法

综上，我们有如下结论：

* 若 $n=m$ ，选第一种
* 若 $n=m+1$ ，哪种都行
* 若 $n\gt m+1$，选第二种

