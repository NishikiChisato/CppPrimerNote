# 处理器体系结构

- [处理器体系结构](#处理器体系结构)
  - [Y86-64 指令集体系结构](#y86-64-指令集体系结构)
    - [程序员可见状态](#程序员可见状态)
    - [Y86-64 指令 \& 指令编码](#y86-64-指令--指令编码)
    - [Y86-64 异常](#y86-64-异常)
  - [Y86-64 的顺序实现](#y86-64-的顺序实现)
    - [指令执行框架](#指令执行框架)
    - [SEQ 硬件结构](#seq-硬件结构)


## Y86-64 指令集体系结构

一条指令被编码为由一个或多个字节序列组成的二进制格式，一个处理器至此的指令和指令的字节级编码称为它的指令集体系结构 `Instruction-Set Architecture, ISA`

### 程序员可见状态

`Y86-64` 程序的每条指令都会读取或修改处理器的状态，这些「状态」被称为程序员可见状态。这里的「程序员」既可以指用汇编写代码的人，也可以指生成机器级代码的编译器（机器级代码也就是汇编代码）

`Y86-64` 的程序员可见状态如下：

* `RF`：程序寄存器
  * 不同与 `x68-64` ，`Y86-64` 只有 $15$ 个 **$64$ 位**寄存器：`%rax, %rcx, %rdx, %rbx, %rsp, %rbp, %rsi, %rdi` 和 `%r8` 到 `%r14`
  * `%rsp` 被入栈、出栈、调用和返回指令作为栈指针，除此以外寄存器没有固定的含义和固定值
* `CC`：条件码
  * `Y86-64` 有 $3$ 个**一位**的条件码：`ZF, SF, OF`，用以保存最近一次算术或逻辑指令所造成的影响
* `PC`：程序计数器
  * 存放当前正在执行的指令的地址（这里不是当前正在执行的指令的下一条指令的地址）
* `Stat`：程序状态
  * 用于表明程序执行的总体状态，是正常运行还是发生某种异常
* `DMEM`：内存
  * `Y86-64` 用虚拟内存来引用内存位置。硬件和操作系统软件联合将虚拟地址映射为实际的物理地址，用于指明数据实际存储在哪个地方（而机器级程序不需要关注这一点）

### Y86-64 指令 & 指令编码

`Y86-64` 的指令集为 `x86-64` 指令集的子集。它只包含 $8$ 字节整数的操作，由于只有 $8$ 字节的数据，因此在此被称为「字」（在 `x86-64` 中，「字」表示 `2 bytes`）

以下为 `Y86-64` 的指令及其字节编码

![Y86-64 ISA](../img/Y86-64%20ISA.png)

图中 $V,D,Dest$ 均为八字节，这些被称为八字节常数字，部分指令需要附加上。具体指令含义如下：

* 数据传送指令有四个，前面的两个字母分别指示内存 `m` 和寄存器 `r` 。数据传送时，同 `x86-64` 一样，不允许从内存直接传送到内存也不允许将立即数传送到内存。关于寻址方式，采用简单的基址加偏移量的形式，没有第二基址寄存器和任何单位的伸缩
* `cmovXX` 表示条件传送指令，有六个：`cmovle, cmovl, cmove, cmovne, cmovge, cmovg` ，只有当状态码满足时才会执行跳转
* `OPq` 表示四个整数操作指令，分别为 `addq, subq, andq, xorq` ，它们只允许对寄存器进行操作（`x86-64` 还允许它们对内存进行操作），并且会设置三个条件码的值
* `jXX` 表示条件跳转指令，有六个，分别为：`jmp, jle, jl, je, jne, jge, jg` ，跳转条件与 `x86-64` 一样
* `call` 指令将返回地址压入栈中，`pop` 指令从栈中弹出返回地址并设置 `PC` 的值
* `halt` 指令用于停止指令的运行，在 `x86-64` 中也有类似的指令 `hlt` ，但应用程序无法执行该指令，因为这会导致整个系统停止运行

后面给出的是每条指令的字节级编码，**第一个字节用于确定指令的类型**。该字节分为两部分，高四位表示代码 `code` ，第四位表示功能 `function ` ，在图中用 `fn` 表示

例如，`OPq` 系列的指令编码如下：

|`Command`|`Byte`|
|:-:|:-:|
|`addq`|`0x60`|
|`subq`|`0x61`|
|`andq`|`0x62`|
|`xorq`|`0x63`|

`Y86-64` 中用数字表示寄存器，这个数字被称为寄存器标识符 `register ID`，数字的范围为 `0x0 ~ 0xE` ，`0xF` 不表示任何寄存器，寄存器序号如下表：

|`ID`|`name`|`ID`|`name`|
|:-:|:-:|:-:|:-:|
|`0`|`%rax`|`8`|`%r8`|
|`1`|`%rcx`|`9`|`%r9`|
|`2`|`%rdx`|`A`|`%r10`|
|`3`|`%rbx`|`B`|`%r11`|
|`4`|`%rsp`|`C`|`%r12`|
|`5`|`%rbp`|`D`|`%r13`|
|`6`|`%rsi`|`E`|`%r14`|
|`7`|`%rdi`|`F`|`NULL`|

`Y86-64` 指令长度从 $1 \sim 10$ 字节不等，具体的编码例子如下：

我们用 $16$ 进制表示指令 `rmovq %rsp, 0x123456789abcd(%rdx)`，其中 `rmmovq` 用 `40` 表示，`$rsp, %rdx` 用 `42` 表示，将数字 `0x123456789abcd` 扩充到 $8$ 字节，为：`00 01 23 45 67 89 ab cd` ，指令采取小端存储，因此合起来为：`40 42 cd ab 89 67 45 23 01 00`

更多的例子：

```assembly
  irmovq $15, %rbx      # 30 f3 0f 00 00 00 00 00 00 00
  rrmovq %rbx, %rcx     # 2021
  rmmovq %rcx, -3(%rbx) # 40 13 fd ff ff ff ff ff ff ff
```

同理，如果我们知道一条指令序列的**开始**，我们便可以翻译出对应的指令

`30 f3 fc ff ff ff ff ff ff ff 40 63 00 08 00 00 00 00 00`

翻译为：

```assembly
  irmovq $-4, %rbx
  rmmovq %rsi, 0x800(%rbx)
  halt
```

### Y86-64 异常

程序员可见状态中的 `stat` 字段描述了程序的运行状态，分别如下：

|`Value`|`Name`|`Details`|
|:-:|:-:|:-:|
|`1`|`AOK`|`正常操作`|
|`2`|`HLT`|`遇到 halt 指令`|
|`3`|`ADR`|`遇到非法地址`|
|`4`|`INS`|`遇到非法指令`|

在程序正常执行时，`stat` 值为 $1$ ，遇到不同的情况 `stat` 的值被设定对应的不同值

在 `Y86-64` 中，遇到异常我们仅仅是简单的**将程序停止**。在一个更完整的设计中，处理器通常会调用异常处理程序 `execption handler` ，该过程用来处理遇到的某种异常。异常处理程序可以被设置为不同的行为，例如终止程序或调用一个用户自定义的信号处理程序 `signal handler`

---

## Y86-64 的顺序实现

### 指令执行框架

处理一条指令需要包含很多个操作，我们可以将不同的操作进行归类，进而得到一个简单的框架用于描述所有指令的执行过程

* 取指 `fetch`：从内存当中读取地址，地址为程序计数器 `PC` 的值。从指令字节中抽取两个 `4-bit` 部分，称为 `icode` (`the instruction code`) 和 `ifun` (`the insrtuction function`)
  * 它有可能取出一个寄存器指示符字节，用以指明一个或两个寄存器 `rA` 与 `rB`
  * 它还有可能取出一个 `8-bit` 常数，用 `valC` 表示（不一定有）
  * 该指令会得到 `valP` ，该值用于表示下一条指令的地址（一定有）
* 译码 `decode`：从寄存器文件中读取最多两个操作数，用 `valA` 和 `valB` 表示，也就是将 `fetch` 阶段得到的寄存器编号所对应的寄存器的值读取出来
* 执行 `execute`：在此阶段，`ALU`(`arithmetic/logic unit`) 要么指令对应的操作（由 `ifun` 指明），**计算内存引用的有效地址**，要么**增加或减少栈指针**，此时得到的值用 `valE` 表示
  * 在此阶段会设置条件码 `set CC` 。而对于一条条件传送或条件跳转指令来说，会检验条件码和传送或跳转条件，如果成立的话则执行传送或跳转，更新目的寄存器
* 访存 `memory`：此阶段会从内存当中读取数据或向内存当中写入数据，从内存当中读取的数据被标记为 `valM`
* 写回 `write back`：此阶段将值写入到寄存器文件当中，最多写入两个
* 更新 PC `update PC`：将 `PC` 设置为下一条指令的地址，也就是 `valP` 的值

这里，我们直接给出 `Y86-64` 的不同指令在该框架下的行为：

![stage_1](../img/stage_1.png)

我们以 `opq` 和 `irmovq` 指令为例来说明这个过程是如何执行的

在 `Fetch` 阶段，将 `PC, PC + 1, PC + 2` 的值分别加载到不同的变量当中

* `icode` 用于辨别该指令属于哪一条指令，`ifun` 用于进行条件判断（对于条件传送和条件跳转指令而言）

* `rA` 与 `rB` 分别存储寄存器标识符，后面的 `R[rA]` 或 `R[rB]` 才会对**寄存器文件**进行访问
 
* `valC` 用于存储该指令的常数，`valP` 用于存储下一条指令的地址

在 `Decode` 阶段，会将寄存器文件当中寄存器的值加载到局部变量 `valA` 或 `valB` 中

在 `Execute` 阶段，会对数值进行计算，并将结果存放在 `valE` 中

在 `Memory` 阶段，会访问内存，读取或者写入，后面的 `push`、`ret`、`call` 指令会使用该阶段

在 `Write back` 阶段，会对寄存器文件进行写入，以更新寄存器的数值

在 `PC update` 阶段，将设置 `PC` 为下一条指令的地址，也就是 `valP` 的地址

![stage_2](../img/stage_2.png)

不难发现，`rmmovq` 和 `mrmovq` 的行为与上面的相同

不同的是，上面的 `valC` 存放的是立即数，这里的 `valC` 存放的是地址的偏移量

![stage_3](../img/stage_3.png)

在 `pushq` 的指令的当中，我们需要将**寄存器 `rA` 与 `%rsp` 的的值加载到 `valA` 和 `valB` 当中**

之后将 `%rsp` 的值减 $8$ ，得到栈指针的新地址，随后是先对内存进行写入，再对 `%rsp` 寄存器的值进行写入

这么做是为了保证以下情况结果的确定性：

```asm
push %rsp
```

在 `x86-64` 中，这么做的结果为，会先将当中 `%rsp` 的值压入栈中，再对 `%rsp` 的值进行更新

我们设计的 `Y86-64` 的设计需要与 `x86-64` 相一致，因此在框架的设计中，`pushq` 指令需要先对内存进行写入，在对寄存器变量进行写入

在 `popq` 指令当中，我们会将 **`%rsp` 的值加载到 `rA` 和 `rB` 中**，然后我们将当前栈指针的值增加以得到新的栈指针的值，将其放在 `valE` 中

随后在内存当中对 `rA` 中存放的地址进行访问（也就是 `%rsp` 的值），将值放到 `valM` 中

在 `Write back` 阶段，是先对 `%rsp` 进行写入，再对 `rA` 进行写入

这是因为在 `x86-64` 中，指令 `popq %rsp` 的结果为：先减小栈指针，然后将新值在内存当中的值复制到 `%rsp` 中

![stage_4](../img/stage_4.png)

这里我们需要对三个指令的过程进行分析

* `jXX` 指令

在 `jXX` 指令中，首先将 `PC` 所指字节标记为 `icode` 和 `ifun` ，随后读取后续的 `Dest` 字段，将其标记为 `valC` ，将下一条指令的地址标记为 `valP`

在执行阶段，会根据指令功能 `ifun` 和控制码 `CC` 来设定 `Cnd` 

最后在更新的时候，依据 `Cnd` 的真假（有多个跳转条件）来判断将 `PC` 更新为 `valC` 还是 `valP`

* `call` 指令

在 `fetch` 阶段，`call` 的过程与 `jXX` 的过程相同

在后续的过程中，会将寄存器 `%rsp` 的值赋给 **`valB`**（只会用到 `valB`） ，并将 `%rsp` 的值减去 `8` 得到的值赋给 `valE`

之后，将 `valP` 压入栈中（下一条指令的地址压入栈中），随后将栈指针向下移动（这里我们可以得出栈指针指向的内存是存放内容的，因此在 `push` 指令中，是先下移栈指针，后写入内存）

然后将 `valC` 赋值给 `PC` （`Dest` 的值）

* `ret` 指令

与 `call` 指令不同的是，`ret` 会将寄存器 `%rsp` 的值复制到 `valA` 和 `valB` 中

随后将栈指针上移，得到的值赋值给 `valE`，随后将 **`valA` 处的内存赋值给 `valM` （从内存当中读取出返回地址），将栈指针的新值赋值给 `%rsp`** 

最后将 `PC` 更新为 `valM` 的值

到此为止我们发现，对于 `Y86-64` 当中所给出的任何一条指令，我们均可以在此框架下对其进行描述，往后我们根据此框架直接给出 `SEQ` (`sequence`) 执行下硬件的 `HDL` 描述，也就是 `SEQ` 的硬件描述

 ### SEQ 硬件结构

