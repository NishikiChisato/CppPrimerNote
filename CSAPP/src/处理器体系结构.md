# 处理器体系结构

- [处理器体系结构](#处理器体系结构)
  - [Y86-64 指令集体系结构](#y86-64-指令集体系结构)
    - [程序员可见状态](#程序员可见状态)
    - [Y86-64 指令 \& 指令编码](#y86-64-指令--指令编码)
    - [Y86-64 异常](#y86-64-异常)


## Y86-64 指令集体系结构

一条指令被编码为由一个或多个字节序列组成的二进制格式，一个处理器至此的指令和指令的字节级编码称为它的指令集体系结构 `Instruction-Set Architecture, ISA`

### 程序员可见状态

`Y86-64` 程序的每条指令都会读取或修改处理器的状态，这些「状态」被称为程序员可见状态。这里的「程序员」既可以指用汇编写代码的人，也可以指生成机器级代码的编译器（机器级代码也就是汇编代码）

`Y86-64` 的程序员可见状态如下：

* `RF`：程序寄存器
  * 不同与 `x68-64` ，`Y86-64` 只有 $15$ 个 **$64$ 位**寄存器：`%rax, %rcx, %rdx, %rbx, %rsp, %rbp, %rsi, %rdi` 和 `%r8` 到 `%r14`
  * `%rsp` 被入栈、出栈、调用和返回指令作为栈指针，除此以外寄存器没有固定的含义和固定值
* `CC`：条件码
  * `Y86-64` 有 $3$ 个**一位**的条件码：`ZF, SF, OF`，用以保存最近一次算术或逻辑指令所造成的影响
* `PC`：程序计数器
  * 存放当前正在执行的指令的地址（这里不是当前正在执行的指令的下一条指令的地址）
* `Stat`：程序状态
  * 用于表明程序执行的总体状态，是正常运行还是发生某种异常
* `DMEM`：内存
  * `Y86-64` 用虚拟内存来引用内存位置。硬件和操作系统软件联合将虚拟地址映射为实际的物理地址，用于指明数据实际存储在哪个地方（而机器级程序不需要关注这一点）

### Y86-64 指令 & 指令编码

`Y86-64` 的指令集为 `x86-64` 指令集的子集。它只包含 $8$ 字节整数的操作，由于只有 $8$ 字节的数据，因此在此被称为「字」（在 `x86-64` 中，「字」表示 `2 bytes`）

以下为 `Y86-64` 的指令及其字节编码

![Y86-64 ISA](../img/Y86-64%20ISA.png)

图中 $V,D,Dest$ 均为八字节，这些被称为八字节常数字，部分指令需要附加上。具体指令含义如下：

* 数据传送指令有四个，前面的两个字母分别指示内存 `m` 和寄存器 `r` 。数据传送时，同 `x86-64` 一样，不允许从内存直接传送到内存也不允许将立即数传送到内存。关于寻址方式，采用简单的基址加偏移量的形式，没有第二基址寄存器和任何单位的伸缩
* `cmovXX` 表示条件传送指令，有六个：`cmovle, cmovl, cmove, cmovne, cmovge, cmovg` ，只有当状态码满足时才会执行跳转
* `OPq` 表示四个整数操作指令，分别为 `addq, subq, andq, xorq` ，它们只允许对寄存器进行操作（`x86-64` 还允许它们对内存进行操作），并且会设置三个条件码的值
* `jXX` 表示条件跳转指令，有六个，分别为：`jmp, jle, jl, je, jne, jge, jg` ，跳转条件与 `x86-64` 一样
* `call` 指令将返回地址压入栈中，`pop` 指令从栈中弹出返回地址并设置 `PC` 的值
* `halt` 指令用于停止指令的运行，在 `x86-64` 中也有类似的指令 `hlt` ，但应用程序无法执行该指令，因为这会导致整个系统停止运行

后面给出的是每条指令的字节级编码，**第一个字节用于确定指令的类型**。该字节分为两部分，高四位表示代码 `code` ，第四位表示功能 `function ` ，在图中用 `fn` 表示

例如，`OPq` 系列的指令编码如下：

|`Command`|`Byte`|
|:-:|:-:|
|`addq`|`0x60`|
|`subq`|`0x61`|
|`andq`|`0x62`|
|`xorq`|`0x63`|

`Y86-64` 中用数字表示寄存器，这个数字被称为寄存器标识符 `register ID`，数字的范围为 `0x0 ~ 0xE` ，`0xF` 不表示任何寄存器，寄存器序号如下表：

|`ID`|`name`|`ID`|`name`|
|:-:|:-:|:-:|:-:|
|`0`|`%rax`|`8`|`%r8`|
|`1`|`%rcx`|`9`|`%r9`|
|`2`|`%rdx`|`A`|`%r10`|
|`3`|`%rbx`|`B`|`%r11`|
|`4`|`%rsp`|`C`|`%r12`|
|`5`|`%rbp`|`D`|`%r13`|
|`6`|`%rsi`|`E`|`%r14`|
|`7`|`%rdi`|`F`|`NULL`|

`Y86-64` 指令长度从 $1 \sim 10$ 字节不等，具体的编码例子如下：

我们用 $16$ 进制表示指令 `rmovq %rsp, 0x123456789abcd(%rdx)`，其中 `rmmovq` 用 `40` 表示，`$rsp, %rdx` 用 `42` 表示，将数字 `0x123456789abcd` 扩充到 $8$ 字节，为：`00 01 23 45 67 89 ab cd` ，指令采取小端存储，因此合起来为：`40 42 cd ab 89 67 45 23 01 00`

更多的例子：

```assembly
  irmovq $15, %rbx      # 30 f3 0f 00 00 00 00 00 00 00
  rrmovq %rbx, %rcx     # 2021
  rmmovq %rcx, -3(%rbx) # 40 13 fd ff ff ff ff ff ff ff
```

同理，如果我们知道一条指令序列的**开始**，我们便可以翻译出对应的指令

`30 f3 fc ff ff ff ff ff ff ff 40 63 00 08 00 00 00 00 00`

翻译为：

```assembly
  irmovq $-4, %rbx
  rmmovq %rsi, 0x800(%rbx)
  halt
```

### Y86-64 异常

程序员可见状态中的 `stat` 字段描述了程序的运行状态，分别如下：

|`Value`|`Name`|`Details`|
|:-:|:-:|:-:|
|`1`|`AOK`|`正常操作`|
|`2`|`HLT`|`遇到 halt 指令`|
|`3`|`ADR`|`遇到非法地址`|
|`4`|`INS`|`遇到非法指令`|

在程序正常执行时，`stat` 值为 $1$ ，遇到不同的情况 `stat` 的值被设定对应的不同值

在 `Y86-64` 中，遇到异常我们仅仅是简单的**将程序停止**。在一个更完整的设计中，处理器通常会调用异常处理程序 `execption handler` ，该过程用来处理遇到的某种异常。异常处理程序可以被设置为不同的行为，例如终止程序或调用一个用户自定义的信号处理程序 `signal handler`

