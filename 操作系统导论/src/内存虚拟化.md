# 内存虚拟化

- [内存虚拟化](#内存虚拟化)
  - [概述](#概述)
  - [抽象：地址空间](#抽象地址空间)
  - [机制：地址转换](#机制地址转换)

## 概述

用户程序所能看见的地址均为**虚拟地址**，应用程序所生成的地址也为虚拟地址。操作系统为每个进程提供一个**假象**，即每个进程都拥有**大量的私有内存**，而操作系统在硬件的帮助下会将这些虚拟地址变为真实的物理地址，这便是内存虚拟化

## 抽象：地址空间

处于交互性 `interativity` 的需要，操作系统需要实现**时分共享**，而最简单的办法是将一个进程占用全部内存运行一段时间，然后停止它并将其**所有的状态信息保存在磁盘上（包括所有的物理内存）**。但这样有一个问题是，运行的太慢了，仅仅是保存寄存器等状态信息的速度还相对较快，但保存所有的内存信息到磁盘就太慢了。因此操作系统在**执行进程切换时，仍将进程的信息保存在内存中**（此时我们讨论的内存为物理内存）

![Shareing memory](../img/Shareing%20memory.png)

如上图所示，每个进程都拥有**全部物理内存** $512kb$ 的一小部分，操作系统每次运行一个进程，而其余的进程则在队列当中进行等待（它们的状态信息依旧存储在内存中）

将所有的进程信息都存储在**物理内存**中，我们很难保证一个进程不会去修改另一个进程的信息，这便引出了隔离 `isolation` 和保护 `protection` 的问题

为了解决直接使用物理内存而导致的问题，操作系统会为所有的**进程**提供一层抽象，这个抽象称之为**地址空间 `address space` **，这便是**虚拟内存**的关键

我们引出了进程的地址空间这一抽象的概念，一个进程的地址空间必须包含该进程的所有内存状态：程序的代码 `code` 用来指示该程序该如何执行；栈 `stack` 用来保存当前函数的调用信息，为局部变量、传递参数、返回值所分配的空间；堆 `heap` 来存储动态分配的内存。因此在进程的地址空间中，我们需要存储这三种信息（当然还有静态初始化的变量，但我们这里不讨论这个）

![Address space](../img/Address%20space.png)

在一个只有 $16kb$ 的**地址空间**中，`code` 部分存放在从 $0$ 开始的地址处，`heap` 和 `stack` 分别向下和向上增长，二者的起始地址分别为 $1kb$ 和 $16kb$。当然，这里堆栈的放置方法只是一种约定，并不是所有的情况都是这样放置

需要说明的是，地址空间的 $0\sim 16kb$ 并不等于实际物理地址的 $0\sim 16kb$，而是被**加载到任意的实际地址空间中**，我们称该过程为内存虚拟化 `virtualizing memory`

> 补充：**所有用户级看到的地址都是虚拟地址**
> 
> C语言中指针的地址、甚至是程序所在的地址都是虚拟地址，因此我们**在汇编语言中所看到的地址也是虚拟地址**
>
> 这里或许会有一个矛盾，汇编语言中的栈指针 `%rsp` 是向低地址增长的，但程序的地址空间中的栈是向高地址增长的，二者不矛盾吗？
>
> 实际上是不矛盾的，首先 `%rsp` 肯定是在地址空间中栈的部分的，只不过这里的栈存储的是该进程所有需要保存在栈上的信息，因此这里实际上可以理解为，**每次函数调用都是在栈顶压入一大块空间（将该函数的栈帧压入）**，然后 **`%rsp` 在该空间内向下移动**
>
> 本质上，用户级程序以及程序员所看到的所有地址都是虚拟地址，这提供地址如何在物理内存中分布的假象，知道实际物理内存地址的只有操作系统和硬件
>
>---
>
> 补充：栈内存与堆内存
> 
> **栈内存的申请和释放由编译器来隐式管理**，因此也被称为自动 `automatic` 内存（所有的变量，函数调用时的函数栈帧等）。**堆内存的申请和释放则由程序员显式地完成**
>
> 由于堆内存不是由编译器自动管理的，便会容易产生申请了内存但没有释放的情况，这被称为**内存泄漏**（进程的堆空间存在无法使用的内存）
>
> 我们在此讨论的问题是，如果程序很快结束，使用 `malloc` 申请内存后不用 `free` 归还，为什么不会发生内存`丢失`
>
> 这里的原因是，**操作系统存在两级的内存管理**
> 
> 第一级是由操作系统所执行的，操作系统在进程执行时将内存空间交给进程，并在进程结束时（无论以何种方式结束）将内存回收；第二级是在每个进程中，进程可以独立管理自己地址空间内的虚拟内存。即使因为忘记使用 `free` 而泄露了堆中的内存，操作系统也会在程序退出时回收所有的空间（包括代码段和堆栈空间）。因此无论地址空间中堆的状态如何，都不会发生内存丢失的问题

---

## 机制：地址转换

