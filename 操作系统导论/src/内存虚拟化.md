# 内存虚拟化

- [内存虚拟化](#内存虚拟化)
  - [概述](#概述)
  - [抽象：地址空间](#抽象地址空间)
  - [机制：地址转换](#机制地址转换)
  - [分段](#分段)

## 概述

用户程序所能看见的地址均为**虚拟地址**，应用程序所生成的地址也为虚拟地址。操作系统为每个进程提供一个**假象**，即每个进程都拥有**大量的私有内存**，而操作系统在硬件的帮助下会将这些虚拟地址变为真实的物理地址，这便是内存虚拟化

## 抽象：地址空间

处于交互性 `interativity` 的需要，操作系统需要实现**时分共享**，而最简单的办法是将一个进程占用全部内存运行一段时间，然后停止它并将其**所有的状态信息保存在磁盘上（包括所有的物理内存）**。但这样有一个问题是，运行的太慢了，仅仅是保存寄存器等状态信息的速度还相对较快，但保存所有的内存信息到磁盘就太慢了。因此操作系统在**执行进程切换时，仍将进程的信息保存在内存中**（此时我们讨论的内存为物理内存）

![Shareing memory](../img/Shareing%20memory.png)

如上图所示，每个进程都拥有**全部物理内存** $512kb$ 的一小部分，操作系统每次运行一个进程，而其余的进程则在队列当中进行等待（它们的状态信息依旧存储在内存中）

将所有的进程信息都存储在**物理内存**中，我们很难保证一个进程不会去修改另一个进程的信息，这便引出了隔离 `isolation` 和保护 `protection` 的问题

为了解决直接使用物理内存而导致的问题，操作系统会为所有的**进程**提供一层抽象，这个抽象称之为**地址空间 `address space` **，这便是**虚拟内存**的关键

我们引出了进程的地址空间这一抽象的概念，一个进程的地址空间必须包含该进程的所有内存状态：程序的代码 `code` 用来指示该程序该如何执行；栈 `stack` 用来保存当前函数的调用信息，为局部变量、传递参数、返回值所分配的空间；堆 `heap` 来存储动态分配的内存。因此在进程的地址空间中，我们需要存储这三种信息（当然还有静态初始化的变量，但我们这里不讨论这个）

![Address space](../img/Address%20space.png)

在一个只有 $16kb$ 的**地址空间**中，`code` 部分存放在从 $0$ 开始的地址处，`heap` 和 `stack` 分别向下和向上增长，二者的起始地址分别为 $1kb$ 和 $16kb$。当然，这里堆栈的放置方法只是一种约定，并不是所有的情况都是这样放置

需要说明的是，地址空间的 $0\sim 16kb$ 并不等于实际物理地址的 $0\sim 16kb$，而是被**加载到任意的实际地址空间中**，我们称该过程为内存虚拟化 `virtualizing memory`

> 补充：**所有用户级看到的地址都是虚拟地址**
> 
> C语言中指针的地址、甚至是程序所在的地址都是虚拟地址，因此我们**在汇编语言中所看到的地址也是虚拟地址**
>
> 这里或许会有一个矛盾，汇编语言中的栈指针 `%rsp` 是向低地址增长的，但程序的地址空间中的栈是向高地址增长的，二者不矛盾吗？
>
> 实际上是不矛盾的，首先 `%rsp` 肯定是在地址空间中栈的部分的，只不过这里的栈存储的是该进程所有需要保存在栈上的信息，因此这里实际上可以理解为，**每次函数调用都是在栈顶压入一大块空间（将该函数的栈帧压入）**，然后 **`%rsp` 在该空间内向下移动**
>
> 本质上，用户级程序以及程序员所看到的所有地址都是虚拟地址，这提供地址如何在物理内存中分布的假象，知道实际物理内存地址的只有操作系统和硬件
>
>---
>
> 补充：栈内存与堆内存
> 
> **栈内存的申请和释放由编译器来隐式管理**，因此也被称为自动 `automatic` 内存（所有的变量，函数调用时的函数栈帧等）。**堆内存的申请和释放则由程序员显式地完成**
>
> 由于堆内存不是由编译器自动管理的，便会容易产生申请了内存但没有释放的情况，这被称为**内存泄漏**（进程的堆空间存在无法使用的内存）
>
> 我们在此讨论的问题是，如果程序很快结束，使用 `malloc` 申请内存后不用 `free` 归还，为什么不会发生内存`丢失`
>
> 这里的原因是，**操作系统存在两级的内存管理**
> 
> 第一级是由操作系统所执行的，操作系统在进程执行时将内存空间交给进程，并在进程结束时（无论以何种方式结束）将内存回收；第二级是在每个进程中，进程可以独立管理自己地址空间内的虚拟内存。即使因为忘记使用 `free` 而泄露了堆中的内存，操作系统也会在程序退出时回收所有的空间（包括代码段和堆栈空间）。因此无论地址空间中堆的状态如何，都不会发生内存丢失的问题

---

## 机制：地址转换

我们假设进程的地址空间必须**连续的存储在内存当中**，地址空间**不是很大**，每个地址空间的**大小完全一样**。在后面的讨论中，我们会逐步放开这些限制，进而得到一个具有普适性的内存虚拟化模型

内存虚拟化的主要技术为地址转换 `address translation` ，全称为基于硬件的地址转换 `hardware-based address translation`。利用这种机制，**硬件**每次都会对内存访问进行处理（包括指令的读取、数据的读取和写入），将指令中的虚拟地址转换为实际的物理地址

这一层支持由硬件提供，而操作系统需要做的是管理内存 `manage memory`，记录占用和空闲的内存位置，保持对内存的控制。类似于 `CPU` 虚拟化，我们在内存虚拟化也会引入直接受限执行的概念，一般由硬件提供虚拟地址到物理地址转换的支持，而操作系统则会在合适的时候介入

那么这里便引出了一个问题：我们要将虚拟内存放到物理内存的什么地方

这时我们引入动态重定位的机制 `dynamic relocation`，也被称为基址和界限机制 `base and bound`

具体地，**每个 `CPU` 都需要两个「硬件」寄存器**：基址 `base` 寄存器和界限 `bound` 寄存器。利用这组基址和界限寄存器，地址空间便可以放在物理内存的任何位置，同时也能保证进程不会访问到其他的数据

我们总是假设虚拟地址空间从 $0$ 开始。当程序开始执行时，操作系统会决定该地址空间在物理内存的实际加载地址，**并将起始地址记录在基址寄存器中**。也就是：

```c
physical address = vritual address + base
```

进程所使用的永远是虚拟地址 `vritual address` ，而硬件则在基址寄存器的基础上加上虚拟地址的数值，进而便可以得到物理地址 `physical address`，随后发给内存系统

**基址寄存器用于确定虚拟地址空间在实际物理地址空间中的起始位置**，而**界限寄存器则用于提供访问保护**。界限寄存器会被设置为一个值，用于表示该地址空间的大小，如果进程的寻址超出该范围或者为负数，则 `CPU` 将触发异常，进程可能被终止

基址与界限寄存器的硬件结构是在芯片中的，每个 `CPU` 一对。我们将 `CPU` 中管理内存的部分称为 `MMU, Memory Management Unit`

需要说明的是，界限寄存器有两种使用方式：记录地址空间大小和记录地址空间的结束地址。这两种方式在逻辑上是等价的，但我们之后的叙述以记录空间大小为准

为了支持硬件的动态重定位，我们需要操作系统在关键时刻接入，以实现**基址和界限的虚拟内存**，操作系统职责如下：

* 提供内存管理

在进程创建时，操作系统需要为进程的地址空间找到物理内存空间。由于我们假设进程的地址空间大小相同，因此操作系统可以很容易地找到空闲的物理内存。操作系统可以将整个物理内存看成一个数组，每个位置标记为空闲或已用。每次有新进程创建时便检索该数据结构（通常称为空闲列表 `free list`），为该进程的地址空间分配物理内存

在进程终止时（正常结束或被强制终止），操作系统需要回收该进程占用的物理地址，放回到空闲列表中

* 提供基址和界限管理

在操作系统进行上下文切换时，由于 `CPU` 只有一对基址和界限寄存器。而对于每个进程，这一对寄存器的值必然不相同，这是因为每个进程的地址空间都被加载到不同的物理地址。因此在上下文切换时，操作系统必须**保存基址和界限寄存器**，放到进程结构 `Process structure` 或进程控制块 `Process Control Block` 中。类似的，当操作系统恢复某个进程时也需要从该进程的进程结构或进程控制块中恢复基址和界限寄存器

* 异常处理

操作系统需要提供一些异常处理程序（操作系统会在系统启动时加载这些程序），用来处理内存方面的异常。例如，如果程序试图越界访问，`CPU` 会触发异常，操作系统则需要对该异常进行处理（一般是直接终止进程或者调用异常处理程序）

需要说明的是，地址转换机制完全由硬件完成，操作系统不需要介入。操作系统介入的点主要是上述这三个方面。多数情况是，操作系统设置完硬件后（基址和界限寄存器、进程相关状态），任由程序在 `CPU` 上运行，只有在发生异常时才进行介入

## 分段

上面的设计有一个问题，堆和栈之间的内存并没有被进程使用，但还是占用了实际内存。因此简单的使用一对基址界限寄存器实现的虚拟内存很浪费实际的物理内存，并且如果物理内存物理提供连续的空间来放在进程的地址空间，那么该进程也无法运行了。我们需要在此基础上改进，使得虚拟内存的方式能够**支持大地址空间而不会过多的浪费物理内存**

